"use strict";
//
// This module serializes input data to be included in a plot def.
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeInput = exports.serializeArray = exports.serializeObjectArray = exports.serializeDataSpec = exports.serializeValueObject = exports.serializeValueArray = void 0;
var utils_1 = require("./utils");
var seriesPlotDefaults = {
    legend: {
        show: false,
    },
};
var dataFramePlotDefaults = {
    legend: {
        show: true,
    },
};
//
// Serialize an array of values.
//
function serializeValueArray(input) {
    var serializedData = {
        series: {
            y: {
                type: input.length > 0
                    ? utils_1.determineType(input[0])
                    : "undefined",
                values: input,
            },
        },
    };
    return serializedData;
}
exports.serializeValueArray = serializeValueArray;
//
// Serialize named data series from an input spec.
//
//
function serializeValueObject(seriesNames, input) {
    var serializedData = {
        series: {},
    };
    for (var _i = 0, seriesNames_1 = seriesNames; _i < seriesNames_1.length; _i++) {
        var seriesName = seriesNames_1[_i];
        var seriesSpec = input[seriesName];
        if (utils_1.isArray(seriesSpec)) {
            if (seriesSpec.length === 0) { // Only want arrays with > 0 elements.
                continue;
            }
            if (Array.isArray(seriesSpec[0])) {
                // It's an array of arrays.
                // Expand out to multiple series.
                var i = 0;
                for (var _a = 0, seriesSpec_1 = seriesSpec; _a < seriesSpec_1.length; _a++) {
                    var array = seriesSpec_1[_a];
                    var generatedSeriesName = seriesName + "." + i;
                    serializedData.series[generatedSeriesName] = {
                        type: utils_1.determineType(array[0]),
                        values: array,
                    };
                    i += 1;
                }
            }
            else {
                serializedData.series[seriesName] = {
                    type: utils_1.determineType(seriesSpec[0]),
                    values: seriesSpec,
                };
            }
        }
        else {
            serializedData.series[seriesName] = {
                type: utils_1.determineType(seriesSpec.values[0]),
                values: seriesSpec.values,
                annotations: seriesSpec.annotations,
            };
        }
    }
    return serializedData;
}
exports.serializeValueObject = serializeValueObject;
//
// Serialize a data spec that has values and annotations.
//
function serializeDataSpec(input) {
    var serializedData = utils_1.isArray(input.values)
        ? serializeArray(input.values)
        : serializeValueObject(Object.keys(input.values), input.values);
    if (input.annotations) {
        if (utils_1.isArray(input.annotations)) {
            for (var _i = 0, _a = Object.keys(serializedData.series); _i < _a.length; _i++) {
                var seriesName = _a[_i];
                var series = serializedData.series[seriesName];
                if (series) {
                    if (!series.annotations) {
                        series.annotations = [];
                    }
                    for (var _b = 0, _c = input.annotations; _b < _c.length; _b++) {
                        var annotation = _c[_b];
                        series.annotations.push(annotation);
                    }
                }
            }
        }
        else {
            for (var _d = 0, _e = Object.keys(input.annotations); _d < _e.length; _d++) {
                var annotatedSeriesName = _e[_d];
                var series = serializedData.series[annotatedSeriesName];
                if (series) {
                    if (!series.annotations) {
                        series.annotations = [];
                    }
                    for (var _f = 0, _g = input.annotations[annotatedSeriesName]; _f < _g.length; _f++) {
                        var annotation = _g[_f];
                        series.annotations.push(annotation);
                    }
                }
            }
        }
    }
    return serializedData;
}
exports.serializeDataSpec = serializeDataSpec;
//
// Serialize an array of objects.
//
function serializeObjectArray(input) {
    if (input.length <= 0) {
        return { series: {} }; // No data.
    }
    var seriesNames = Object.keys(input[0]);
    if (seriesNames.length <= 0) {
        return { series: {} }; // No data.
    }
    var serializedData = {
        series: {},
    };
    var _loop_1 = function (seriesName) {
        var values = input.map(function (obj) { return obj[seriesName]; });
        serializedData.series[seriesName] = {
            type: utils_1.determineType(values[0]),
            values: values,
        };
    };
    for (var _i = 0, seriesNames_2 = seriesNames; _i < seriesNames_2.length; _i++) {
        var seriesName = seriesNames_2[_i];
        _loop_1(seriesName);
    }
    return serializedData;
}
exports.serializeObjectArray = serializeObjectArray;
//
// Serialize a data array.
//
function serializeArray(data) {
    if (data.length > 0 && utils_1.isObject(data[0])) {
        return serializeObjectArray(data);
    }
    else {
        return serializeValueArray(data);
    }
}
exports.serializeArray = serializeArray;
//
// Serialize input data to the standard format according to its type.
//
function serializeInput(input) {
    var isInputArray = utils_1.isArray(input);
    var isInputObject = !isInputArray && utils_1.isObject(input);
    var isValueArray = isInputArray && !utils_1.isObject(input[0]);
    if (isValueArray) {
        return [serializeValueArray(input), seriesPlotDefaults];
    }
    else if (isInputObject) {
        var columnNames = Object.keys(input);
        if (columnNames.length === 1 && columnNames[0] === "values") {
            return [serializeDataSpec(input), dataFramePlotDefaults];
        }
        else if (columnNames.length === 2 && columnNames[0] === "values" && columnNames[1] === "annotations") {
            return [serializeDataSpec(input), dataFramePlotDefaults];
        }
        else {
            return [serializeValueObject(columnNames, input), dataFramePlotDefaults];
        }
    }
    else {
        return [serializeObjectArray(input), dataFramePlotDefaults];
    }
}
exports.serializeInput = serializeInput;
//# sourceMappingURL=serialize.js.map